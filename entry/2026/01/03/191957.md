---
Title: データ構造とアルゴリズム-O表記でのコード最適化とO表記なしでのコード最適化-
Category:
- 読書メモ
Date: 2026-01-03T19:19:57+09:00
URL: https://a-nnmgmg8989.hatenablog.com/entry/2026/01/03/191957
EditURL: https://blog.hatena.ne.jp/a-nnmgmg8989/a-nnmgmg8989.hatenablog.com/atom/entry/17179246901339950868
---

[https://amzn.asia/d/4REIJNZ:title

### これは、メモです！
これは、私のための私のメモです。

**決まり**

* コードは、JS・TSのみ
* 実際に書いて覚える
* 記事の長さは、気にしない！

**なんで、この本を読むの？**

* おすすめしてもらったから！
* 自分の思想を持ちたい。
* データ構造・アルゴリズムについてちゃんと話せるようになりたい！

## O表記でのコード最適化とO表記なしでのコード最適化
> 同じ性能に見える2つのアルゴリズムをどのように見分けて、どのように速い方を選ぶかを学ぶ。

実用的な話になった！<br>
こういう話を求めていた！<br>
どうして速いの？その証明はどのようにするの？が気になるところ！<br>

一つ前で実装を確認したバブルソートと今回確認した選択ソートの比較↓<br>

<figure class="figure-image figure-image-fotolife" title="バブルソートと選択ソート">[f:id:a-nnmgmg8989:20260103174029j:plain]<figcaption>バブルソートと選択ソート</figcaption></figure>

> 比較表から、選択ソートはがバブルソートのほぼ半分のステップ数だとわかり、二倍速いことが示される。

選択ソートでは、全ての数字と比較して、一度入れ替えを行う。<br>
バブルソートはすべての比較で入れ替えが必要・この分だけステップ数が嵩む<br>
入れ替えの数が一度なためバブルソートより速い<br>

> **定数を無視**
しかし、O表にはおかしなところがある。選択ソートとバブルソートがまったく同じように表されるのだ。

急に意味がわからなくなったぞ？<br>
ステップ数が全然違うのに一緒ってどゆこと？<br>

> O表記は「N個のデータ要素があれば、アルゴリズムはどれだけのステップかかるか」という本質的な問題に答える。選択ソートはN2のほぼ半分のステップがかかるので、選択ソートの性能をO(N2/N)と表すのは納得できる。

> 選択ソートとバブルソートと同じO表記ではO(N2)で表される

ほ〜ん？なぜ？<br>
1/2の速さなのに、ステップ数なのに？<br>

> **O表記では定数を無視する**
O表記では指数以外に定数を含まないという数字の言い回しだ。式から定数は取り除く。<br>
今回の場合、アルゴリズムはN2/2ステップかかるのだが、「/2」を定数だから落として、性能はO(N2)と表す。

なぜ、落とした！<br>
重要なところを！！！<br>

> アルゴリズムの速度についてO表記は一般的なカテゴリーしか扱わないということだ。

一般的なカテゴリー？<br>
本文を読んでみると、「データが増えたときのアルゴリズムのステップ数の長期的な推移を問題にする」とある<br>
これは、O表記で違うものは明白に増え方に差があるので、O表記を比べれば性能の甲乙がわかる<br>
ここで問題なのが、O表記が同じ場合である<br>
同じ場合はより詳しくステップ数が増えているかを確認する必要がある<br>
選択ソートとバブルソートを比べるように定数などを確認する必要が出てくる<br>

より詳しく調べるとはどんなことだろう？<br>
下に続く<br>


## コードを確認してみた
1章で出てきたコードで確認してみる<br>
このコードは、両方NステップかかるためO(N)になる<br>
両方同じO(N)になるが、最初に確認した通り`print_numbers_version_two`の方が二倍速い<br>

> より詳しく調べたらどちらが速いかわかるもうひとつの例だ


このように、詳しく調べる必要があることがわかった<br>

```
const print_numbers_version_one = () => {
    let number = 2
    while (number <= 100) {
        if (number % 2 === 0) {
            console.log(number);
        }
        number += 1
    }
}

const print_numbers_version_two = () => {
    let number = 2
    while (number <= 100) {
        // 偶数なら出力
        if (number % 2 === 0) {
            console.log(number);
        }
        number += 2
    }
}
```

> O表記では、定数を取り除くので、式が単純になる。
全ステップを数えると、比較がN、増加がN、出力がN/2、足すと2.5Nステップになる。定数2.5を落として、O(N)と表す。
どのステップが重要か、すべてだと言ったが、定数を落としたので、ループの中で何が起こっているかよりは、ループの回数に焦点を当てたといえる。

何がどれだけどのぐらい、ステップ数がかかるかを確認して、定数を落としたときにどこに焦点を当てているかを確認するのがいいのか<br>

> 重要な分析ツールが手に入った。O表記を使ってアルゴリズムの性能を幅広く決定し、O表記で同じ分類になる複数のアルゴリズムを比較できる。


れなっちは、新たな武器を手に入れた！

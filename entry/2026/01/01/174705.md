---
Title: データ構造とアルゴリズム-そうだ、O表記だ-
Category:
- 読書メモ
Date: 2026-01-01T17:47:05+09:00
URL: https://a-nnmgmg8989.hatenablog.com/entry/2026/01/01/174705
EditURL: https://blog.hatena.ne.jp/a-nnmgmg8989/a-nnmgmg8989.hatenablog.com/atom/entry/17179246901338774084
---

[https://amzn.asia/d/4REIJNZ:title]

### これは、メモです！
これは、私のための私のメモです。

**決まり**

* コードは、JS・TSのみ
* 実際に書いて覚える
* 記事の長さは、気にしない！

**なんで、この本を読むの？**

* おすすめしてもらったから！
* 自分の思想を持ちたい。
* データ構造・アルゴリズムについてちゃんと話せるようになりたい！

## そうだ、O表記だ
名前は、知ってる<br>
大体の表記法も知っている<br>
利点もわかる<br>
定義や他の人が全体像を掴めるように説明ができない・・・<br>

> O表記(Big-O notation)として知られているこの概念の表現方式は、アルゴリズムの効率化をカテゴリに分けることを容易にして、他の人とのコミュニケーションの助けになる。

O表記に関しては、基本情報やアルゴリズムの際に見たことがあって知ってたけど、定義を説明できなかった。<br>
**O表記**：アルゴリズムの効率化をカテゴリに分けることを容易にするツール<br>
他の人との共通認識としてもっておくと便利<br>


> O表記は**アルゴリズムのステップ数に焦点を絞ること**で一貫性を得るが、かなり特殊だ。<br>

> O(N)のアルゴリズム：線形時間<br>
線形探索にはNステップかかるからO(N)と書く<br>

> O(1)：定数時間<br>
「N個のデータ要素があれば、配列から読むのにどれだけのステップがかかるか」を求めるO表記<br>
配列はどれだけ大きくても配列から読むのに1ステップしかかからないため、最速のアルゴリズム<br>

確かに、ステップ数を求める際に　必ず１回で終わるものは最速になる！

**O表記の定義**：<br>
> 「N個のデータ要素があれば、アルゴリズムにどれだけのステップがかかるか」という本質的な問題の答え<br>

**O表記の精神**：<br>
> アルゴリズムの性能がデータの増加とともにどう変化するかを表す
> データの個数が変わるときに、どのようにステップ数が変わるかというお話しを伝えたいのだ

定義はわかりやすいけど、精神の方も理解した上で当てはめる必要がある。<br>
実際のステップ数にとらわれずに、増加率を認識して当てはめることを意識しなきゃ<br>

> 悲観的な見方の方が役にたつ。最悪のシナリオでアルゴリズムがどれだけ非効率かをはっきり知っていれば、選択に大きな影響を及ぼす最悪シナリオに準備できるかただ。

一番時間がかかる予測でシナリオを作成することはなにがあっても大体それぐらいで終わることがわかる。<br>
それで時間が間に合うのなら、何があっても間に合うことができるシナリオになる<br>
このシナリオはいいシナリオと認識！

**O(log N)**：二分探索<br>
対数時間の時間計算量<br>
データが倍になるとステップが1つ増えるアルゴリズムを示すO表記<br>
O(1)より劣るが、O(N)よりはるかに優れる<br>
O(log2 N)の省略系<br>


logは、対数(logarithm)の短縮系なんだ<br>

**対数**：べき乗の逆演算<br>
log2８は、8という結果を得るには、2を何回掛けないといけないかの答え<br>
log2８は、2を3回掛けると8になったので、log2８=3

これは、わかりやすい<br>
「数の悪魔」を読んでてよかった<br>
[https://www.shobunsha.co.jp/?p=1008:embed:cite]
対数であることが分かれば配列の要素に応じて何ステップかかるかを認識するのも容易<br>

##  次際にコードを動かしてみた

> どんなことをするコードでも厳密にはアルゴリズム、問題解決のプロセスになる。

今回は、時間を測ったり早さを確認するのではなく「このアルゴリズムの性能をO表記でどう記述するか」を確認していく！<br>
それには、何が**問題**で、**解決するためのプロセスとして何を行なっているか**を認識していく<br>

```
const things = [`apples`, `baboons`, `cribs`, `dulcimers`];

things.forEach(item => {
    console.log(`"Here's a thing: %s" % ${item}`);
})
```

> 問題はリスト全要素を出力すること
> 問題を解くのに使うアルゴリズムは、console.log文を含むforEachループである。

確かに、アルゴリズム全てに**問題と回答**がある<br>
いつも解くアルゴリズムにも存在する<br>
意識して、O表記であれば何に当てはまるかも検討しながらアルゴリズムを書かなきゃ<br>

> fotEachループは、要素数だけのステップがかかるので、このアルゴリズムは性能がO(N)だ

だいたいループがあると、総当たりなので、O(N)とかになる気がしてきた！<br>

練習問題として、本にはもう少し載っている<br>

今回は、定義や精神、当てはめる方法が書いてあった。<br>

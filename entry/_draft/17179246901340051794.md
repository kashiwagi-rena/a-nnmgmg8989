---
Title: データ構造とアルゴリズム-楽観的なシナリオで最適化-
Category:
- 読書メモ
EditURL: https://blog.hatena.ne.jp/a-nnmgmg8989/a-nnmgmg8989.hatenablog.com/atom/entry/17179246901340051794
PreviewURL: https://a-nnmgmg8989.hatenablog.com/draft/entry/moWic-TRH1pTrh3ns4EnsX1MXcA
Draft: true
---

https://amzn.asia/d/4REIJNZ:title

### これは、メモです！
これは、私のための私のメモです。

**決まり**

* コードは、JS・TSのみ
* 実際に書いて覚える
* 記事の長さは、気にしない！

**なんで、この本を読むの？**

* おすすめしてもらったから！
* 自分の思想を持ちたい。
* データ構造・アルゴリズムについてちゃんと話せるようになりたい！

## 楽観的なシナリオで最適化

ずっと悲観的だったじゃん！<br>

> ここまでは、主として最悪なシナリオでアルゴリズがどれだけのステップかかるかを調べてきた。その背景にあるのは、最悪時に備えておけば大丈夫だという単純な理由だ。<br>
しかし、本章では、最悪シナリオだけが考慮すべき状況ではないことを学ぶ。<br>

**最悪時に備えておけば大丈夫だ**<br>
データ構造や条件が未確定の場合は大体この考えな気がする(重要なことが未確定の場合、その情報を確定する方がいいと思います)<br>

> O表記にはさらに次のような規則がある
> **複数の次数が加わっている場合、O表記では最高次の次数だけに注目する**

O表記の規則多いので、暗記すること<br>
だたし、暗記だけだと具体例がなくて覚えにくいのでちゃんとアルゴリズムを解くこと<br>

> 最悪シナリオでは選択ソートが挿入ソートより速い。しかし、平均時のシナリオが一番頻繁に起こる。最良シナリオと最悪シナリオは比較的に稀だ。

<figure class="figure-image figure-image-fotolife" title="釣り鐘曲線">[f:id:a-nnmgmg8989:20260121001512j:plain]<figcaption>釣り鐘曲線</figcaption></figure>
<figure class="figure-image figure-image-fotolife" title="グラフ">[f:id:a-nnmgmg8989:20260121001555j:plain]<figcaption>グラフ</figcaption></figure>
<figure class="figure-image figure-image-fotolife" title="表">[f:id:a-nnmgmg8989:20260121001602j:plain]<figcaption>表</figcaption></figure>

最悪シナリオを基準に考えるのは、最悪シナリオ以上に遅くなることがないからでしかない<br>
現実世界で起きるのが多いのは、平均シナリオなのは当たり前で、数が多いのは配慮すべきである。<br>
「状況によっては、早くも遅くもなる」アルゴリズムの選択の答えは、状況による<br>
最近読んでる本全部に「状況による」「正解はない」って書いてある・・・経験値ほしい〜<br>


**挿入ソート**：最悪シナリオ以外での分析の威力が示される<br>
以下、記事に挿入ソートの説明とJSのコードあり<br>
[https://zenn.dev/joeee/articles/d9bd0983601c4d:embed:cite]

```
const insertion_sort = (array: number[]) => {
    for (let index = 1; index < array.length; index++) {
        const temp_value = array[index]
        let position = index - 1;

        while ( position >= 0) {
            if ( array[position] > temp_value ) {
                array[position + 1] = array[position]
                position = position - 1
            } else {
                break
            }
        }
        array[position + 1] = temp_value
    }
    return array
}
```



---
Title: データ構造とアルゴリズム-なぜアルゴリズムは重要か-
Category:
- 読書メモ
Date: 2025-12-31T17:20:51+09:00
URL: https://a-nnmgmg8989.hatenablog.com/entry/2025/12/31/172051
EditURL: https://blog.hatena.ne.jp/a-nnmgmg8989/a-nnmgmg8989.hatenablog.com/atom/entry/17179246901336676038
---

[https://amzn.asia/d/4REIJNZ:title]

### これは、メモです！
これは、私のための私のメモです。

**決まり**

* コードは、JS・TSのみ
* 実際に書いて覚える
* 記事の長さは、気にしない！

**なんで、この本を読むの？**

* おすすめしてもらったから！
* 自分の思想を持ちたい。
* データ構造・アルゴリズムについてちゃんと話せるようになりたい！

## なぜアルゴリズムは重要か
重要だろ<br>
なんでかは、ちゃんと説明できんけど

> アルゴリズムという用語は複雑に聞こえるが、実際にはそんなことはない。
アルゴリズムとは、ある仕事を完了するための一連の命令にすぎない<br>
> コンピューティングでは、アルゴリズムはある業務を遂行するためにコンピュータに与えられる一連の命令を指す

一連の命令<br>
PCに対しての一連の命令のこと<br>
それ以外の意味がない方が広くてむずい<br>
会話の中で出てきたら、「どのことを指しているんだろう？」ってなりそう<br>

> コードを書いたなら、コンピュータがそれにしたがって実行するアルゴリズムを作ったことになる

？？？コードを書いただけでアルゴリズムを作ったことになるのか<br>
コードは、PCに与える一連の命令だからか！<br>
なんとなくわかったけど、なんとなくわからん・・・これは、何がわからないかわからないやつ・・・<br>

**順序付き配列**：基本的な配列とほぼ同じ。相違点は、値が順序よく並んでいること。挿入には、N + 2ステップ必要<br>
探索には、二分探索という選択肢があるということが優位性<br>

> 順序付き配列への挿入は、そもそも探索の必要がない基本的な配列へのよりは遅いままだ

何が必要で、必要な機能にはどれが早くてあっているかをちゃんと考えながら使うことを意識<br>

> データが、倍になると二分探索アルゴリズムは１ステップ増える
> 二分探索を使うと１回の試行で半分のセルを排除できる

> 二分探索の素晴らしいところは、探索のたびに残り半分の要素を候補から外すことだ

二分探索は、半分ずつ排除できる<br>
どれだけ数が多くても、半分ずつ減らすことができる

> どんな状況でも、1つにデータ構造やアルゴリズムが完全ということはまずないと認識しておくことが**重要**だ
> 競合するアルゴリズムの分析には、それぞれのステップ数を数える

認識はしているけど、「先輩の書くコードは、完璧！」とかよく思っちゃう<br>
ステップ数を比べられるほどの経験値の差なのか・・・いっぱい書けって、言われるのはそういう意味か！<br>
わかるけど、程遠い〜<br>

##  次際にコードを動かしてみた
arrayの長さが、5でまず動かします。<br>
**線形探索**

```
const linear_search = (array, search_value) => {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === search_value) {
            return i;
        } else if (array[i] > search_value) {
            return null;
        }
    }
    return null;
}

console.log(linear_search([3, 17, 75, 80, 202], 22));
```
結果はこんな感じ

```
検索結果: null
実行時間: 0.0121 ミリ秒
```

**二分探索**
```
const binary_search = (array: number[], search_value: number): number | null => {
    let lower_bound = 0;
    let upper_bound = array.length - 1;

    while (lower_bound <= upper_bound) {
        const midpoint = Math.floor((upper_bound + lower_bound) / 2);
        const value_at_midpoint = array[midpoint];

        if (search_value === value_at_midpoint) {
            return midpoint;
        } else if (search_value < value_at_midpoint) {
            upper_bound = midpoint - 1;
        } else if (search_value > value_at_midpoint) {
            lower_bound = midpoint + 1;
        }
    }
    return null;
}

```
結果は、こんな感じ
```   
検索結果: null
実行時間: 0.0190 ミリ秒
```

二分探索の方が、ちょっと遅い？<br>
コード的に長く、`else if`の個数も多いため処理に時間がかかっている様子<br>

二分探索の本領発揮は、これからです<br>

一気に`array`の数を100まで増やしたいと思います<br>

22があるかどうかを探索します<br>

**線形探索**
```
検索結果: 10
実行時間: 0.0135 ミリ秒
```

**二分探索**
```
検索結果: 10
実行時間: 0.0213 ミリ秒
```

100でも時間が変わりませんでしたw<br>
なんなら、二分探索の方が遅くない？<br>

次は81があるかどうかを探索します<br>
あれ？変わらない？<br>

**線形探索**
```
検索結果: null
実行時間: 0.0167 ミリ秒
```

**二分探索**
```
検索結果: null
実行時間: 0.0164 ミリ秒
```

## kiroちゃんの教え
ちょっと教えをいただきました。<br>
```
=== 性能比較テスト ===
配列サイズ: 10
線形探索平均: 0.000295 ms
二分探索平均: 0.000280 ms
二分探索の方が 1.05倍 高速
---
配列サイズ: 100
線形探索平均: 0.001887 ms
二分探索平均: 0.000118 ms
二分探索の方が 15.96倍 高速
---
配列サイズ: 1000
線形探索平均: 0.000581 ms
二分探索平均: 0.000110 ms
二分探索の方が 5.28倍 高速
---
配列サイズ: 10000
線形探索平均: 0.004510 ms
二分探索平均: 0.000108 ms
二分探索の方が 41.74倍 高速
---
```
欲しかった結果！<br>
配列のサイズが大きくなればなるほど、二分探索の方が高速になります<br>

**実際の使い分け**
小さい配列（<20要素）: 線形探索でも十分<br>
中〜大きい配列（>20要素）: 二分探索が有利<br>
非常に大きい配列（>1000要素）: 二分探索が圧倒的に有利<br>

配列サイズが2倍になると：<br>
線形探索: 実行時間も約2倍<br>
二分探索: 実行時間は+1ステップのみ（log₂の性質）<br>

自分でコード動かすのたのしい！
